#!/usr/bin/env python

#
# Copyright (C) 2014-2015 by Sebastian Deiss, all rights reserved.
#
# QR2Auth reference implementation in Python.
#
#
# The MIT License (MIT)
#
# Copyright (c) 2014-2015 Sebastian Deiss
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


from __future__ import print_function
from Crypto.Random.random import StrongRandom, Random
from Crypto.Hash import HMAC, SHA512

import qrcode.image.svg
import base64
import string


class QR2Auth(object):
    '''
    QR2Auth reference implementatin.
    This class provides the core functionality for the
    challenge response protocol.
    '''
    def __init__(self, shared_secret=None):
        '''
        Constructor.

        :param str shared_secret: The users shared secret.
        '''
        self.__challenge = None                 # QR2Auth challenge
        self.__start = None                     # Start of OTP range
        self.__end = None                       # End of OTP range
        self.__shared_secret = shared_secret    # The users shared secret
        self.__otp_length = 8                   # 8 hexdigest OTP

    def set_shared_secret(self, shared_secret):
        '''
        Setter for shared secret

        :param str shared_secret: The users shared secret.
        :rtype: void
        '''
        self.__shared_secret = shared_secret

    def set_challenge(self, challenge):
        '''
        Setter for the challenge

        :param str challenge: The QR2Auth challenge.
        :rtype: void
        '''
        self.__challenge = challenge

    def get_challenge(self):
        '''
        Generate a QR2Auth challenge.
        A QR2Auth challenge consists of 128 random bits generated by PyCrypto
        with StrongRandom.
        These random bits are hashed with SHA512. This hash value represents
        the challenge.

        :return: A tuple containing the QR2Auth challenge as well as the range
                 of the OTP in the response hash value.
        :rtype: tuple
        '''
        random_pool = StrongRandom()
        nonce = random_pool.getrandbits(128)
        nonce_hash = SHA512.new(str(nonce)).hexdigest()
        self.__start = int(random_pool.randint(0, 128))
        '''
        Start and end of the range must be between 0 and the length of the hash
        We use Sha512, so in this case start and end must be between
        0 and 128
        '''
        self.__end = self.__start + self.__otp_length
        if self.__end > len(nonce_hash):
            self.__end = self.__end - len(nonce_hash)
        self.__challenge = nonce_hash
        return self.__challenge, self.__start, self.__end

    def keygen(self):
        '''
        Generate the secret key for QR2Auth aka shared secret.
        A QR2Auth secret key consists of 256 random bits generated by PyCrypto
        with StrongRandom.
        The random bits are hashed with SHA512. This hash value
        represents the secret key aka. shared secret.

        :return: A QRtoAuth shared secret.
        :rtype: str
        '''
        random_pool = StrongRandom()
        key_seed = random_pool.getrandbits(256)
        key = SHA512.new(str(key_seed))
        self.__shared_secret = key.hexdigest()
        return self.__shared_secret

    def xor_key(self):
        '''
        Bitwise XOR the shared secret with the pin.

        :return: A tuple containing the PIN and the XORed
                 shared secret.
        :rtype: tuple
        '''
        # The PIN has 4 digits and we need 128 digits for
        # XOR with the shared secret
        pin = self.__pwgen()
        padded_pin = pin * 32
        '''
        convert strings to a list of character pair tuples
        go through each tuple, converting them to ASCII code (ord)
        perform exclusive or on the ASCII code
        then convert the result back to ASCII (chr)
        merge the resulting array of characters as a string
        '''
        xored = ''.join(chr(ord(a) ^ ord(b)) for a,  b in zip(padded_pin,
                                                             self.__shared_secret))
        return pin, base64.encodestring(xored)

    def make_otp(self):
        '''
        Create a QR2Auth one-time password

        :return: Returns a QR2Auth one-time password
        :rtype: str
        '''
        otp_hash = HMAC.new(self.__shared_secret, self.__challenge, SHA512)
        if self.__end < self.__start:
            otp = otp_hash.hexdigest()[self.__start:]
            otp += otp_hash.hexdigest()[:self.__end]
            return otp
        else:
            return otp_hash.hexdigest()[self.__start:self.__end]

    def verify_response(self, received_otp, start, end):
        '''
        Verify the One time password (OTP) aka response.
        A QR2Auth Response consists of 8 digests of the HMAC-SHA512 value
        from the challenge with the shared_secret used as key for the HMAC.

        :param str received_otp: The submitted one time password from the
                                 client.
        :param str start: Start of the OTP range
        :param str end: End of the OTP range
        :return: True if the OTP is valid otherwise False
        :rtype: bool
        '''
        otp_hash = HMAC.new(self.__shared_secret,
                            self.__challenge.__str__(), SHA512)

        # convert the range values from strings to integers
        start = int(start)
        end = int(end)

        if end < start:
            otp = otp_hash.hexdigest()[start:]
            otp += otp_hash.hexdigest()[:end]
        else:
            otp = otp_hash.hexdigest()[start:end]

        if otp == received_otp:
            return True
        return False

    def qrgen(self, is_key=False, key=''):
        '''
        Generate an SVG image containing the QR code

        :param str content: A SHA512 hash value that represents the key or the
                            challenge
        :param str type: Specifies the type of the hash value
                         (key or challenge).
        :return: An image object containing the SVG image
        :rtype: Object
        '''
        qrfactory = qrcode.image.svg.SvgImage
        # generate the QR code
        if is_key is True:
            '''
            Add a prefix so that another application can distinguish the key
            from the challenge.
            '''
            qr_content = '{key}'
            qr_content += key
            # test vectors
            key_hmac = HMAC.new(self.__shared_secret, self.__shared_secret, SHA512)
            qr_content += ','
            qr_content += key_hmac.hexdigest()
            # make the QR code
            qrimg = qrcode.make(qr_content,
                                image_factory=qrfactory)
            '''
            qrimg = qrcode.make('{key}' + self.shared_secret,
                                image_factory=qrfactory)
            '''
        else:
            qrimg = qrcode.make('{' + str(self.__start) + ',' +
                                str(self.__end) + '}' +
                                self.__challenge, image_factory=qrfactory)
        return qrimg

    #
    # Internals
    #
    def __pwgen(self, size=4, chars=string.digits):
        '''
        Generate a password. This password is used as the PIN
        for the bitwise XOR of the shared secret.

        :param str size: The length of the password
        :param str chars: The characters the password should contain.
                          In this case we only want digits.
        :return: A generated digit password
        :rtype: string
        '''
        return ''.join(Random.random.choice(chars) for _ in range(size))


def main():
    qrimg_keyfile = 'QR2Auth-Key.svg'
    qrimg_challenge_file = 'QR2Auth-Challenge.svg'
    q2a = QR2Auth()

    # Generate a shared secret
    __shared_secret = q2a.keygen()
    print('QR2Auth plain shared secret: ')
    print(__shared_secret)
    # XOR the shared secret with a PIN
    PIN, xored_ss = q2a.xor_key()
    print('QR2Auth protected shared secret:')
    print(xored_ss)
    print('PIN for this protected shared secret:')
    print(PIN)
    # Set the shared secret
    q2a.set_shared_secret(__shared_secret)

    # Genrate a challenge
    challenge, start, end = q2a.get_challenge()
    print('QR2Auth challenge: ')
    print(challenge)
    print('OTP Range: %s:%s' % (start, end))

    # Create a one-time password
    otp = q2a.make_otp()
    print('One-time password: ' + otp)
    # Verify the OTP
    status = q2a.verify_response(otp, start, end)
    if status:
        print('OTP match')
    else:
        print('OTP does not match')

    # Save the shared secret in a QR code image
    qrimg = q2a.qrgen(is_key=True, key=xored_ss)
    qrimg.save(qrimg_keyfile)
    # Save the challenge in a QR code image
    qrimg = q2a.qrgen()
    qrimg.save(qrimg_challenge_file)


if __name__ == '__main__':
    main()
